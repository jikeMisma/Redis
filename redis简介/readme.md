
**什么是redis？ 为什么 怎么用？**


### 1.0 Redis简介
Redis是完全开源免费的，遵守BSD协议的高性能（NOSQL）的key-value数据库，是一个开源的用ANSI C语言编写的、支持网络、可基于内存亦可持久化的日志型，key-value数据库，并提供多种语言的API

### 1.1NOSQL

NOSQL泛指非关系型的数据库，NOSQL即not-Only SQL ，他可以作为关系型数据库的良好补充



传统的关系型数据库应付web2.0 提别是超大规模和高并发的SNS类型的web2.0的纯动态网站已经显得力不从心，暴露了很多难以克服的问题。例如：

1.High erformance- 对于数据库高并发的读写需求
2.Huge Storage age -对数据库的高效率存储访问需求
3.High Scalablity && Hige Availablity -对于数据库的高可扩展性和高可用性的需求



### 1.2NOSQL的类别
键值（key-value）存储数据库
这类数据库会使用到一个哈希表，这个表中会有特定的键和一个指针指向忑顶的数据key-value模型对于IT系统来说优势在于简单、易部署、但是DBA只对于部分值查询或者更新的时候，key-value就显得效率低下了。

相关产品：Tokyo、Cablinet、Redis、Voldemort
典型应用：内容缓存，主要用于处理大浪数据的高访问负载
数据模型：一系列键值对
优势：快速查询
劣势：存储的数据缺少结构化





列存储数据库
这部分数据库通常是用来对应分布式存储的海量数据，键任然存在，但他们的特点是指向了多个列，这些列是由列家族安排的。

相关产品：Cassandra、HBase、Riak
典型应用：分布式的文件系统
数据模型：以列簇式存储，将同一列数据存在一起
又是：查找速度快、可扩展性强、更容易进行分布式扩展
劣势：功能相对局限




文档型数据库


图形数据库

**总结：**

1. NOSQL数据库在以下几种情况中比较适用：
2. 数据模型比较简单
3. 需要星火性更强的IT系统
4. 对数据库性能要求高
5. 不需要高度的数据一致性
6. 对于给定的key，比较容易映射复杂环境
7. NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据的应用难题

### 1.3Redis特点

* 性能极高：Redis能读的速度是1100000次/秒,写的速度是810000次/秒
* 丰富的数据类型：Redis支持string、hash、List、set、以及Ordered set数据类型的操作
* 原子性：Redis的所有操作都是原子性的，多个操作也支持事务，通过MULTI和EXEC指令包起来
* 丰富的特性：Redis还支持publish/subscribe。通知、key过期等特性
* 高速读写：Redis使用自己实现的分离器，代码量很短、没有使用lock，因此效率高

### 1.4Redis的应用场景
企业开发中：可以用作数据库、缓存、热点数据（经常被查询、但是不经常被修改或者删除的数据）和消息中间件当大部分功能

redis的常用场景如下：

1. 缓存
缓存现在几乎是所有中大型网站都在用的必杀技，合理利用缓存不仅能够提升网站访问速度、还能大大降低数据库的压力、redis提供了键过期功能也提供了键淘汰策略，所以Redis用缓存的场景非常多。

2. 排行榜
Redis提供的有序集合数据类结构能够实现各种复杂的排行榜应用

3. 计数器
什么是计数器，如网站商品的浏览量、视频网站视频的播放数等

4. 分布式会话
在集群模式下搭建咦Redis等内存数据为中心的session服务

5.分布式锁
可以利用Redis的setnx功能来编写分布式锁

6. 消息系统
消息队列是大型网站比用的中渐渐，如ActiveMQ、RabbitMQ、Kafka等，主要用于业务解耦、流量削峰以及异步处理实时性低的业务。redis提供了发布/订阅以及阻塞队列功能，能实现一个简单的消息队列系统。




### 1.5Redis总结
#### 1.5.1 redis优势

* 性能极高：Redis能读的速度是1100000次/秒,写的速度是810000次/秒

* 丰富的数据类型：Redis支持string、hash、List、set、以及Ordered set数据类型的操作
* 原子性：Redis的所有操作都是原子性的，多个操作也支持事务，通过MULTI和EXEC指令包起来
* 丰富的特性：Redis还支持publish/subscribe。通知、key过期等特性
* 高速读写：Redis使用自己实现的分离器，代码量很短、没有使用lock，因此效率高
#### 1.5.2 Redis缺点

* 持久化：RDB和AOF
* 耗内存：内存占用过高




